import pytest
from datetime import timedelta, datetime, timezone
from unittest.mock import AsyncMock, patch

from fastapi import HTTPException, status
from jose import jwt

from backend.app.services.auth_service import (
    create_user,
    verify_password,
    create_access_token,
    create_refresh_token,
    _decode_token,
    get_user,
    authenticate_user,
    verify_refresh_token,
    get_current_user,
)
from backend.app.models import User
from backend.app.config import (
    SECRET_KEY,
    ALGORITHM,
    ACCESS_TOKEN_EXPIRE_MINUTES,
    REFRESH_TOKEN_EXPIRE_DAYS,
)


# Mock the auth_service.users collection for unit tests
@pytest.fixture(autouse=True)
def mock_auth_service_users():
    with patch(
        "backend.app.services.auth_service.users", new_callable=AsyncMock
    ) as mock_users:
        yield mock_users


@pytest.fixture
def mock_user_data():
    return {
        "name": "Test",
        "surname": "User",
        "email": "test@example.com",
        "password": "TestPassword1!",
    }


@pytest.fixture
def mock_user_in_db_data():
    return {
        "_id": "user123",
        "name": "Test",
        "surname": "User",
        "email": "test@example.com",
        "hashed_password": "hashedpassword",
        "isAdmin": False,
    }


@pytest.mark.asyncio
async def test_create_user(mock_auth_service_users, mock_user_data):
    mock_auth_service_users.insert_one.return_value = AsyncMock()
    with patch(
        "backend.app.services.auth_service.generate_user_id", new_callable=AsyncMock
    ) as mock_generate_user_id:
        mock_generate_user_id.return_value = "new_user_id"
        user = User(**mock_user_data)
        created_user = await create_user(user)

        assert created_user["email"] == mock_user_data["email"]
        assert "hashed_password" in created_user
        assert created_user["_id"] == "new_user_id"
        mock_auth_service_users.insert_one.assert_called_once()


def test_verify_password():
    hashed_password = "hashedpassword"  # In a real scenario, this would be generated by pwd_context.hash
    with patch("backend.app.services.auth_service.pwd_context") as mock_pwd_context:
        mock_pwd_context.verify.return_value = True
        assert verify_password("plainpassword", hashed_password) is True
        mock_pwd_context.verify.return_value = False
        assert verify_password("wrongpassword", hashed_password) is False


def test_create_access_token():
    data = {"sub": "test@example.com"}
    token = create_access_token(data)
    decoded_payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    assert decoded_payload["sub"] == data["sub"]
    assert "exp" in decoded_payload
    # Check if expiration is roughly correct (within a small margin)
    expected_exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )
    assert (
        decoded_payload["exp"] - expected_exp_time.timestamp() < 5
    )  # Allow for a few seconds difference


def test_create_refresh_token():
    data = {"sub": "test@example.com"}
    token = create_refresh_token(data)
    decoded_payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    assert decoded_payload["sub"] == data["sub"]
    assert "exp" in decoded_payload
    # Check if expiration is roughly correct (within a small margin)
    expected_exp_time = datetime.now(timezone.utc) + timedelta(
        days=REFRESH_TOKEN_EXPIRE_DAYS
    )
    assert (
        decoded_payload["exp"] - expected_exp_time.timestamp() < 5
    )  # Allow for a few seconds difference


def test_decode_token_success():
    data = {"sub": "test@example.com"}
    token = create_access_token(data, expires_delta=timedelta(minutes=1))
    email = _decode_token(token)
    assert email == data["sub"]


def test_decode_token_expired():
    data = {"sub": "test@example.com"}
    token = create_access_token(
        data, expires_delta=timedelta(minutes=-1)
    )  # Expired token
    with pytest.raises(HTTPException) as exc_info:
        _decode_token(token)
    assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
    assert exc_info.value.detail == "Signature has expired"


def test_decode_token_invalid():
    invalid_token = "invalid.jwt.token"
    with pytest.raises(HTTPException) as exc_info:
        _decode_token(invalid_token)
    assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
    assert exc_info.value.detail == "Could not validate credentials"


def test_decode_refresh_token_expired():
    data = {"sub": "test@example.com"}
    token = create_refresh_token(
        data, expires_delta=timedelta(days=-1)
    )  # Expired refresh token
    with pytest.raises(HTTPException) as exc_info:
        _decode_token(token, is_refresh_token=True)
    assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
    assert exc_info.value.detail == "Token has expired"


@pytest.mark.asyncio
async def test_get_user_exists(mock_auth_service_users, mock_user_in_db_data):
    mock_auth_service_users.find_one.return_value = mock_user_in_db_data
    user = await get_user("test@example.com")
    assert user.email == mock_user_in_db_data["email"]
    assert user.id == mock_user_in_db_data["_id"]
    mock_auth_service_users.find_one.assert_called_once_with(
        {"email": "test@example.com"}
    )


@pytest.mark.asyncio
async def test_get_user_not_exists(mock_auth_service_users):
    mock_auth_service_users.find_one.return_value = None
    user = await get_user("nonexistent@example.com")
    assert user is None
    mock_auth_service_users.find_one.assert_called_once_with(
        {"email": "nonexistent@example.com"}
    )


@pytest.mark.asyncio
async def test_authenticate_user_success(mock_auth_service_users, mock_user_in_db_data):
    mock_auth_service_users.find_one.return_value = mock_user_in_db_data
    with patch("backend.app.services.auth_service.verify_password", return_value=True):
        user = await authenticate_user("test@example.com", "testpassword")
        assert user.email == mock_user_in_db_data["email"]


@pytest.mark.asyncio
async def test_authenticate_user_wrong_password(
    mock_auth_service_users, mock_user_in_db_data
):
    mock_auth_service_users.find_one.return_value = mock_user_in_db_data
    with patch("backend.app.services.auth_service.verify_password", return_value=False):
        user = await authenticate_user("test@example.com", "wrongpassword")
        assert user is None


@pytest.mark.asyncio
async def test_authenticate_user_not_found(mock_auth_service_users):
    mock_auth_service_users.find_one.return_value = None
    user = await authenticate_user("nonexistent@example.com", "testpassword")
    assert user is None


@pytest.mark.asyncio
async def test_verify_refresh_token_success(
    mock_auth_service_users, mock_user_in_db_data
):
    mock_auth_service_users.find_one.return_value = mock_user_in_db_data
    with patch(
        "backend.app.services.auth_service._decode_token",
        return_value="test@example.com",
    ):
        user = await verify_refresh_token("valid_refresh_token")
        assert user.email == mock_user_in_db_data["email"]


@pytest.mark.asyncio
async def test_verify_refresh_token_invalid_token():
    with patch(
        "backend.app.services.auth_service._decode_token",
        side_effect=HTTPException(status_code=401),
    ):
        with pytest.raises(HTTPException) as exc_info:
            await verify_refresh_token("invalid_refresh_token")
        assert exc_info.value.status_code == 401


@pytest.mark.asyncio
async def test_verify_refresh_token_user_not_found(mock_auth_service_users):
    mock_auth_service_users.find_one.return_value = None
    with patch(
        "backend.app.services.auth_service._decode_token",
        return_value="nonexistent@example.com",
    ):
        with pytest.raises(HTTPException) as exc_info:
            await verify_refresh_token("valid_refresh_token")
        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED


@pytest.mark.asyncio
async def test_get_current_user_success(mock_auth_service_users, mock_user_in_db_data):
    mock_auth_service_users.find_one.return_value = mock_user_in_db_data
    with patch(
        "backend.app.services.auth_service._decode_token",
        return_value="test@example.com",
    ):
        user = await get_current_user("valid_access_token")
        assert user.email == mock_user_in_db_data["email"]


@pytest.mark.asyncio
async def test_get_current_user_invalid_token():
    with patch(
        "backend.app.services.auth_service._decode_token",
        side_effect=HTTPException(status_code=401),
    ):
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user("invalid_access_token")
        assert exc_info.value.status_code == 401


@pytest.mark.asyncio
async def test_get_current_user_user_not_found(mock_auth_service_users):
    mock_auth_service_users.find_one.return_value = None
    with patch(
        "backend.app.services.auth_service._decode_token",
        return_value="nonexistent@example.com",
    ):
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user("valid_access_token")
        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED


def test_user_password_validation():
    # Test password too short
    with pytest.raises(ValueError, match="Password must be at least 8 characters long"):
        User(name="Test", surname="User", email="test@example.com", password="Short1!")

    # Test password missing number
    with pytest.raises(ValueError, match="Password must contain at least one number"):
        User(
            name="Test", surname="User", email="test@example.com", password="NoNumbers!"
        )

    # Test password missing uppercase
    with pytest.raises(
        ValueError, match="Password must contain at least one uppercase letter"
    ):
        User(
            name="Test",
            surname="User",
            email="test@example.com",
            password="nouppercase1!",
        )

    # Test password missing lowercase
    with pytest.raises(
        ValueError, match="Password must contain at least one lowercase letter"
    ):
        User(
            name="Test",
            surname="User",
            email="test@example.com",
            password="NOLOWERCASE1!",
        )

    # Test password missing special character
    with pytest.raises(
        ValueError, match="Password must contain at least one special character"
    ):
        User(
            name="Test", surname="User", email="test@example.com", password="NoSpecial1"
        )

    # Test valid password
    try:
        User(
            name="Test",
            surname="User",
            email="test@example.com",
            password="ValidPassword1!",
        )
    except ValueError as e:
        pytest.fail(f"Valid password raised ValueError: {e}")
